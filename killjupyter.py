# -*- coding: utf-8 -*-
"""killjupyter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1urwEzMpziwQHB9yPRWsbFEywLQ62A011
"""

import pandas as pd

#데이터프레임에 각 테이블을 지정하는 과정
#쥬피터 노트북환경에서 하면 좋은 점 발견: 내용이 많은 데이터셋의 경우 매번 실행시키면 오래걸리기 때문에 데이터프레임을 한번 받아두고 다른 창에서 바로 명령문 실행 가능

path1 = '/content/sample_data/games.csv'
path2 = '/content/sample_data/games_details.csv'
path3 = '/content/sample_data/ranking.csv'

games = pd.read_csv(path1,low_memory=False)
wj_games = games.drop(columns=['GAME_DATE_EST','GAME_STATUS_TEXT','TEAM_ID_home','TEAM_ID_away'], inplace=False)
wj_games = wj_games[wj_games['SEASON']>=2019]
#GAME_ID를 통해 경기별로 분류 1=비정규,2=정규,3=플레이오프,4=플레이인
wj_games['SEASON_NAME']=wj_games['GAME_ID'] // 10000000

#pd.set_option('display.max_columns',None)


games_details = pd.read_csv(path2,low_memory=False)
wj_games_details = games_details.drop(columns=['NICKNAME','START_POSITION'], inplace=False)

ranking = pd.read_csv(path3,low_memory=False)
wj_ranking = ranking.drop(columns=['LEAGUE_ID','RETURNTOPLAY'], inplace=False)
wj_ranking['SEASON']=wj_ranking['SEASON_ID'].apply(lambda x : 2022 if x == 22022 else (
                                                                2021 if x == 22021 else (
                                                                2020 if x == 22020 else 2019
                                                                )
))
wj_ranking = wj_ranking[wj_ranking['SEASON_ID']>=20000] #비시즌(맨앞자리가 1은 프리시즌, 2는 정규시즌) 제거
wj_ranking=wj_ranking.drop(columns='SEASON_ID',inplace=False)
wj_ranking

#함수 선언 - PCT 컬럼을 계산하기 위함.

def pctmean(series):
    return series.mean() * 10

#랭킹 데이터에서 각 시즌별 성적 뽑기
pd.to_datetime(wj_ranking['STANDINGSDATE'])
#rankingdata에서 각 시즌 마지막 일자별 팀 기록 추출
roofmax = [2021,2020,2019]
maxdata = wj_ranking.loc[wj_ranking['SEASON']==2022,'STANDINGSDATE'].max()
rk_table = wj_ranking[wj_ranking['STANDINGSDATE']==maxdata].copy()
rk_table
for i in roofmax:
    maxdata = wj_ranking.loc[wj_ranking['SEASON']==i,'STANDINGSDATE'].max()
    rooftable = wj_ranking[wj_ranking['STANDINGSDATE']==maxdata].copy()
    rk_table = pd.concat([rk_table,rooftable])

rk_table = rk_table.drop(columns=['STANDINGSDATE'],inplace=False)
rk_table=rk_table.reset_index()
rk_table.drop(columns=['index'],inplace=True)
rk_table

#COPY()를 사용하지 않으면 하위 테이블이 변화되었을때 상위 테이블에 영향을 줄 수 있음.
H_games = wj_games[['GAME_ID','SEASON_NAME','SEASON','HOME_TEAM_ID','PTS_home','FG_PCT_home','FT_PCT_home','FG3_PCT_home','AST_home','REB_home']].copy()
H_games['HA'] = 1
A_games = wj_games[['GAME_ID','SEASON_NAME','SEASON','VISITOR_TEAM_ID','PTS_away','FG_PCT_away','FT_PCT_away','FG3_PCT_away','AST_away','REB_away']].copy()
A_games['HA'] = 2
H_games.columns = ['GAME_ID','SEASON_NAME','SEASON','TEAM_ID','PTS','FG_PCT','FT_PCT','FG3_PCT','AST','REB','HA']
A_games.columns = ['GAME_ID','SEASON_NAME','SEASON','TEAM_ID','PTS','FG_PCT','FT_PCT','FG3_PCT','AST','REB','HA']
T_games = pd.concat([H_games,A_games])#.sort_values(by='SEASON',ascending=False)
T_games=T_games[T_games['SEASON_NAME']==2]
T_games=T_games.drop(columns=['GAME_ID','SEASON_NAME'])
T_games.groupby(['SEASON','TEAM_ID']).agg({'PTS':['mean','median'],
                                           'FG_PCT':[pctmean],
                                           'FT_PCT':[pctmean],
                                           'FG3_PCT':[pctmean],
                                           'AST':['mean','median'],
                                           'REB':['mean','median'],
                                           'HA':'sum'
                                           })

#games_details 테이블에 시즌이라는 개념 추가, 2019 ~ 2022 시즌만 짜르기
Season_player = wj_games_details[21900000<=wj_games_details['GAME_ID']]
Season_player = Season_player[Season_player['GAME_ID']<23000000]

#시즌 컬럼 만들기
#시즌 나누기
Season_player['SEASON'] = Season_player['GAME_ID'].apply(lambda x : 2022 if round((x/100000)-200,0)==22 else
                                                                (2021 if round((x/100000)-200,0)==21 else
                                                                (2020 if round((x/100000)-200,0)==20 else 2019 )))
#팀 LA_LAKERS만 뽑아보기
LA_lakers = Season_player[Season_player['TEAM_ABBREVIATION']=='LAL'].copy()

#당장 불필요한 컬럼 정리, Season별 혹은 LA레이커스 선수들의 시즌별 데이터 정리, cnt_season은 게임수를 groupby 후에 mean() 또는 sum()을 해주어야해서 GAME_ID 컬럼을 삭제하기 전에 이용
Season_player.drop(columns=['TEAM_ID','TEAM_ABBREVIATION','TEAM_CITY','COMMENT'],inplace=True)
cnt_season=Season_player.groupby(['GAME_ID','PLAYER_ID','PLAYER_NAME','SEASON'])[[
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS']].sum()
Season_player.drop(columns=['GAME_ID'],inplace=True)
#Season_player = Season_player.fillna(0) #결측값제거 (0으로 대체) 결측값 제거시 경기수 측정하기 불편.
sn_count = Season_player[['PLAYER_ID','PLAYER_NAME','SEASON','FGM']].groupby(['PLAYER_ID','PLAYER_NAME','SEASON']).count().reset_index()
sn_count.columns = ['PLAYER_ID','PLAYER_NAME','SEASON','GP'] #전체팀들의 선수들 출전수
LA_lakers.drop(columns=['GAME_ID','TEAM_ID','TEAM_ABBREVIATION','TEAM_CITY','COMMENT'],inplace=True)
#LA_lakers = LA_lakers.fillna(0) #결측값제거 (0으로 대체) 결측값 제거시 경기수 측정하기 불편.
la_count= LA_lakers[['PLAYER_ID','PLAYER_NAME','SEASON','FGM']].groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])['FGM'].count().reset_index()
la_count.columns = ['PLAYER_ID','PLAYER_NAME','SEASON','GP'] #LA레이커스의 출전수
sn_count.sort_values(by='PLAYER_NAME',ascending=False)

#cnt_season이라는 선수들의 시즌별 시즌 스탯 정리
cnt_season=pd.merge(cnt_season,sn_count,on=['PLAYER_ID','PLAYER_NAME','SEASON'],how='inner') #cnt_season 테이블에 count(GP=출전 수) 값 추가
cnt_season=Season_player.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[[
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS'
                        ]].agg({'PTS':['mean','sum'],
                                'FGM':['mean','sum'],
                                'FGA':['mean','sum'],
                                'FG3M':['mean','sum'],
                                'FG3A':['mean','sum'],
                                'FTM':['mean','sum'],
                                'FTA':['mean','sum'],
                                'REB':['mean','sum'],
                                'OREB':['mean','sum'],
                                'DREB':['mean','sum'],
                                'AST':['mean','sum'],
                                'BLK':['mean','sum'],
                                'TO':['mean','sum'],
                                'PF':['mean','sum'],
                                'FG_PCT':['mean'],
                                'FG3_PCT':[pctmean],
                                'FT_PCT':[pctmean]
                                }).reset_index().sort_values(by='PLAYER_NAME',ascending=False)
#cnt_season=pd.merge(cnt_season,sn_count,on=['PLAYER_ID','PLAYER_NAME','SEASON'],how='inner') #cnt_season 테이블에 count(GP=출전 수) 값 추가

Season_player['SEASON'] = Season_player['SEASON'].astype(int)

LA_lakers['EFFICIENCY'] = ((
    LA_lakers['PTS'] +
    LA_lakers['REB'] +
    LA_lakers['AST'] +
    LA_lakers['STL'] +
    LA_lakers['BLK']
    ) - (
        (LA_lakers['FGA'] - LA_lakers['FGM']) +
        (LA_lakers['FTA'] - LA_lakers['FTM']) +
        LA_lakers['TO']
    ))
LA_lakers

#Season_player 테이블에서 MIN 값 변환
# min > min.float
def min_to_float(min_str):
    try:
        return float(min_str)
    except:
        pass
    try:
        m, s = map(int, str(min_str).split(':'))
        return m + s/60
    except:
        return None

#밑에거 "한번만" 실행
Season_player.loc[:, 'MIN'] = Season_player.loc[:, 'MIN'].apply(min_to_float)
wj_games_details.loc[:, 'MIN'] = wj_games_details.loc[:, 'MIN'].apply(min_to_float)

#games_details 테이블에서 팀별 기록값도 나누어보기
Season_team = wj_games_details[21900000<=wj_games_details['GAME_ID']]
Season_team = Season_team[Season_team['GAME_ID']<23000000]
#시즌 컬럼 만들기
#시즌 나누기
Season_team['SEASON'] = Season_team['GAME_ID'].apply(lambda x : 2022 if round((x/100000)-200,0)==22 else
                                                                (2021 if round((x/100000)-200,0)==21 else
                                                                (2020 if round((x/100000)-200,0)==20 else 2019 )))

Season_team.drop(columns=['PLAYER_ID','PLAYER_NAME','TEAM_CITY','COMMENT'],inplace=True)
Season_team=Season_team.groupby(['GAME_ID','TEAM_ID','SEASON','TEAM_ABBREVIATION']).sum().reset_index()
Season_team.drop(columns=['GAME_ID'],inplace=True)
copy_team=Season_team.copy()
Season_team=Season_team.groupby(['TEAM_ID','SEASON','TEAM_ABBREVIATION']).agg({'PTS':['mean','sum'],
                                                                               'FGM':['mean','sum'],
                                                                               'FGA':['mean','sum'],
                                                                               'FG3M':['mean','sum'],
                                                                               'FG3A':['mean','sum'],
                                                                               'FTM':['mean','sum'],
                                                                               'FTA':['mean','sum'],
                                                                               'REB':['mean','sum'],
                                                                               'OREB':['mean','sum'],
                                                                               'DREB':['mean','sum'],
                                                                               'AST':['mean','sum'],
                                                                               'BLK':['mean','sum'],
                                                                               'TO':['mean','sum'],
                                                                               'PF':['mean','sum'],
                                                                               'FG_PCT':[pctmean],
                                                                               'FG3_PCT':[pctmean],
                                                                               'FT_PCT':[pctmean]
                                                                               }).reset_index()

Season_team[Season_team['TEAM_ABBREVIATION']=='LAL']

copy_team

#시즌별 각 컨퍼러스의 플레이오프 진출권 팀 정보(12팀)
rk_table['SEASON'] = rk_table['SEASON'].astype(int)

#2022시즌(사실상 현순위)
Eplayoff=rk_table[(rk_table['SEASON']==2022)&(rk_table['CONFERENCE']=='East')].sort_values(by='W_PCT',ascending=False).head(6)
Wplayoff=rk_table[(rk_table['SEASON']==2022)&(rk_table['CONFERENCE']=='West')].sort_values(by='W_PCT',ascending=False).head(6)
playoff=pd.concat([Eplayoff,Wplayoff])
playoff=playoff[['TEAM_ID','TEAM','W_PCT','SEASON']].reset_index()

stat_2022=pd.merge(playoff,copy_team,on=['TEAM_ID','SEASON'],how='inner')
stat_2022.drop(columns=['TEAM','TEAM_ABBREVIATION','TEAM_ID','PLUS_MINUS','W_PCT','index'],inplace=True)
meanstat_2022=stat_2022.groupby(['SEASON']).mean().reset_index()
meanstat_2022['FG_PCT']=meanstat_2022['FGM']/meanstat_2022['FGA']
meanstat_2022['FG3_PCT']=meanstat_2022['FG3M']/meanstat_2022['FG3A']
meanstat_2022['FT_PCT']=meanstat_2022['FTM']/meanstat_2022['FTA']

#2021
Eplayoff=rk_table[(rk_table['SEASON']==2021)&(rk_table['CONFERENCE']=='East')].sort_values(by='W_PCT',ascending=False).head(6)
Wplayoff=rk_table[(rk_table['SEASON']==2021)&(rk_table['CONFERENCE']=='West')].sort_values(by='W_PCT',ascending=False).head(6)
playoff=pd.concat([Eplayoff,Wplayoff])
playoff=playoff[['TEAM_ID','TEAM','W_PCT','SEASON']].reset_index()
stat_2021=pd.merge(playoff,copy_team,on=['TEAM_ID','SEASON'],how='inner')
stat_2021.drop(columns=['TEAM','TEAM_ABBREVIATION','TEAM_ID','PLUS_MINUS','W_PCT','index'],inplace=True)
meanstat_2021=stat_2021.groupby(['SEASON']).mean().reset_index()
meanstat_2021['FG_PCT']=meanstat_2021['FGM']/meanstat_2021['FGA']
meanstat_2021['FG3_PCT']=meanstat_2021['FG3M']/meanstat_2021['FG3A']
meanstat_2021['FT_PCT']=meanstat_2021['FTM']/meanstat_2021['FTA']

#2020
Eplayoff=rk_table[(rk_table['SEASON']==2020)&(rk_table['CONFERENCE']=='East')].sort_values(by='W_PCT',ascending=False).head(6)
Wplayoff=rk_table[(rk_table['SEASON']==2020)&(rk_table['CONFERENCE']=='West')].sort_values(by='W_PCT',ascending=False).head(6)
playoff=pd.concat([Eplayoff,Wplayoff])
playoff=playoff[['TEAM_ID','TEAM','W_PCT','SEASON']].reset_index()
stat_2020=pd.merge(playoff,copy_team,on=['TEAM_ID','SEASON'],how='inner')
stat_2020.drop(columns=['TEAM','TEAM_ABBREVIATION','TEAM_ID','PLUS_MINUS','W_PCT','index'],inplace=True)
meanstat_2020=stat_2020.groupby(['SEASON']).mean().reset_index()
meanstat_2020['FG_PCT']=meanstat_2020['FGM']/meanstat_2020['FGA']
meanstat_2020['FG3_PCT']=meanstat_2020['FG3M']/meanstat_2020['FG3A']
meanstat_2020['FT_PCT']=meanstat_2020['FTM']/meanstat_2020['FTA']

#2019
Eplayoff=rk_table[(rk_table['SEASON']==2019)&(rk_table['CONFERENCE']=='East')].sort_values(by='W_PCT',ascending=False).head(6)
Wplayoff=rk_table[(rk_table['SEASON']==2019)&(rk_table['CONFERENCE']=='West')].sort_values(by='W_PCT',ascending=False).head(6)
playoff=pd.concat([Eplayoff,Wplayoff])
playoff=playoff[['TEAM_ID','TEAM','W_PCT','SEASON']].reset_index()
stat_2019=pd.merge(playoff,copy_team,on=['TEAM_ID','SEASON'],how='inner')
stat_2019.drop(columns=['TEAM','TEAM_ABBREVIATION','TEAM_ID','PLUS_MINUS','W_PCT','index'],inplace=True)
meanstat_2019=stat_2019.groupby(['SEASON']).mean().reset_index()
meanstat_2019['FG_PCT']=meanstat_2019['FGM']/meanstat_2019['FGA']
meanstat_2019['FG3_PCT']=meanstat_2019['FG3M']/meanstat_2019['FG3A']
meanstat_2019['FT_PCT']=meanstat_2019['FTM']/meanstat_2019['FTA']

#LAlakers의 시즌 스탯
LAL = copy_team[copy_team['TEAM_ABBREVIATION']=='LAL']
LAL = LAL.drop(columns=['TEAM_ID','TEAM_ABBREVIATION','PLUS_MINUS'])
LAL['FG_PCT']=LAL['FGM']/LAL['FGA']
LAL['FG3_PCT']=LAL['FG3M']/LAL['FG3A']
LAL['FT_PCT']=LAL['FTM']/LAL['FTA']
LAL=LAL.groupby('SEASON').mean()
LAL=LAL.reset_index()
LAL_2019=LAL[LAL['SEASON']==2019]
LAL_2020=LAL[LAL['SEASON']==2020]
LAL_2021=LAL[LAL['SEASON']==2021]
LAL_2022=LAL[LAL['SEASON']==2022]

# efficiency 계산 공식 적용
eff=Season_player.copy()
eff['EFFICIENCY'] = ((
    eff['PTS'] +
    eff['REB'] +
    eff['AST'] +
    eff['STL'] +
    eff['BLK']
    ) - (
        (eff['FGA'] - eff['FGM']) +
        (eff['FTA'] - eff['FTM']) +
        eff['TO']
    ))

corr_eff = eff.copy()
corr_eff = corr_eff.drop(columns=['PLAYER_ID','PLAYER_NAME','SEASON'],inplace=False)
corr_eff['PF'] = corr_eff['PF']*-1
corr_eff = corr_eff.corr()
corr_eff=corr_eff['EFFICIENCY']

corr_eff=pd.DataFrame(corr_eff)
corr_eff=corr_eff.sort_values(by='EFFICIENCY',ascending=False)

corr_eff

#선수 스탯과 승률(W_PCT)의 상관관계

#히트맵 시각화(전체팀)
#corrteam -> W_PCT와 전체 다른 스탯들과의 상관관계
#corrLA -> LA_LAKERS의 승률 및 선수들의 스탯과 상관관계

import numpy as np
import seaborn as sns

#1.전체 선수-승률 상관관계
test_team=copy_team.groupby(['TEAM_ID','SEASON','TEAM_ABBREVIATION']).mean()
corrLA=copy_team[copy_team['TEAM_ID']==1610612747] #???
test_team=test_team.reset_index()

corrteam = pd.merge(rk_table,test_team,on=['TEAM_ID','SEASON'],how='inner')
corrteam=corrteam.drop(columns=['TEAM_ABBREVIATION','PLUS_MINUS','G','W','L','HOME_RECORD','ROAD_RECORD'],inplace=False)
corrMLA=corrteam[corrteam['TEAM']=='L.A. Lakers']
corrteam=corrteam.groupby(['TEAM_ID','SEASON','TEAM','W_PCT','CONFERENCE']).mean()
corrteam['FG_PCT']=corrteam['FGM']/corrteam['FGA']
corrteam['FG3_PCT']=corrteam['FG3M']/corrteam['FG3A']
corrteam['FT_PCT']=corrteam['FTM']/corrteam['FTA']
corrteam=corrteam.reset_index().drop(columns=['TEAM','TEAM_ID','SEASON','CONFERENCE'],inplace=False)
corrteam=corrteam.corr()
corrteam=corrteam['W_PCT']

corrteam=pd.DataFrame(corrteam)
corrteam=corrteam.sort_values(by='W_PCT',ascending=False)

#2. LA_Lakers의 선수-승률 상관관계
corrLA = corrLA.reset_index()
corrLA = pd.merge(rk_table,corrLA,on=['TEAM_ID','SEASON'],how='inner')
corrLA = corrLA.drop(columns=['TEAM_ABBREVIATION','G','W','L','HOME_RECORD','ROAD_RECORD','index','PLUS_MINUS'])
corrLA=corrLA.groupby(['TEAM_ID','SEASON','TEAM','W_PCT','CONFERENCE']).mean().reset_index()
corrLA['FG_PCT']=corrLA['FGM']/corrLA['FGA']
corrLA['FG3_PCT']=corrLA['FG3M']/corrLA['FG3A']
corrLA['FT_PCT']=corrLA['FTM']/corrLA['FTA']
#시즌을 나누기 전의 경계선
corrLA=corrLA.drop(columns=['TEAM','TEAM_ID','SEASON','CONFERENCE'],inplace=False)
corrLA['PF']=corrLA['PF']*-1
corrLA=corrLA.corr()
corrLA=corrLA['W_PCT']

corrLA=pd.DataFrame(corrLA)
corrLA=corrLA.sort_values(by='W_PCT',ascending=False)

corrLA

#Test code

corrMLA['FG_PCT']=corrMLA['FGM']/corrMLA['FGA']
corrMLA['FG3_PCT']=corrMLA['FG3M']/corrMLA['FG3A']
corrMLA['FT_PCT']=corrMLA['FTM']/corrMLA['FTA']
#시즌을 나누기 전의 경계선
corrMLA=corrMLA.drop(columns=['TEAM_ID','SEASON','CONFERENCE','TEAM'],inplace=False)
corrMLA=corrMLA.corr()
corrMLA=corrMLA['W_PCT']

corrMLA=pd.DataFrame(corrLA)
corrMLA=corrMLA.sort_values(by='W_PCT',ascending=False)

corrMLA

#시각화를 위한 코딩

import matplotlib.pyplot as plt

fig, axes = plt.subplots(1,2, figsize=(14, 6))

mask = np.zeros_like(corrteam, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
cmap = sns.diverging_palette(230,11, as_cmap=True)
cor1 = sns.heatmap(corrteam, mask=mask, cmap = cmap,ax=axes[0], annot=True)
axes[0].set_title('All Teams Correlation') # 첫 번째 서브플롯 제목 설정

mask = np.zeros_like(corrLA, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
cmap = sns.diverging_palette(230,11, as_cmap=True)
cor2 = sns.heatmap(corrLA, mask=mask, cmap = cmap,ax=axes[1], annot=True)
axes[1].set_title('LA_Lakers Correlation') # 첫 번째 서브플롯 제목 설정

plt.show()

#comment 테이블 만들기 (gmaes_details 기반)

cmt_name=wj_games_details[['PLAYER_ID','PLAYER_NAME','COMMENT']].sort_values(by=['PLAYER_NAME','COMMENT'],ascending=False)
cmt_name

#결측값 제거 후 표준화해주기
#표준화가 필요한 데이터셋 (stat_2019~2022, LAL_2019~2022)

#sklearn 가져오기. (표준화에 필요한 라이브러리)
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

#표준화 작업
sk19 = scaler.fit_transform(stat_2019.loc[:,'FGM':'PTS'])
sk19 = scaler.fit_transform(sk19)
sk19 = pd.DataFrame(sk19,columns=stat_2019.loc[:,'FGM':'PTS'].columns)
stat_2019.loc[:,'FGM':'PTS'] = sk19
stat_2019

#Efficiency

mask = np.zeros_like(corr_eff, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
cmap = sns.diverging_palette(230,11, as_cmap=True)
cor1 = sns.heatmap(corr_eff, mask=mask, cmap = cmap, annot=True)
cor1.set_title('Efficiency Correlaion') # 첫 번째 서브플롯 제목 설정

lakers22 = LA_lakers[LA_lakers['SEASON']==2022].copy()
#lakers22 = lakers22.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
#                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS'
#                        ]].mean()
lakers22

lakers21 = LA_lakers[LA_lakers['SEASON']==2021].copy()
lakers21['EFFICIENCY'] = ((
    lakers21['PTS'] +
    lakers21['REB'] +
    lakers21['AST'] +
    lakers21['STL'] +
    lakers21['BLK']
    ) - (
        (lakers21['FGA'] - lakers21['FGM']) +
        (lakers21['FTA'] - lakers21['FTM']) +
        lakers21['TO']
    ))

lakers21 = lakers21.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[[
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','EFFICIENCY'
                        ]].mean().reset_index()

lakers21

#

LA_lakers = LA_lakers.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[[
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','EFFICIENCY'
                        ]].mean()
LA_lakers = LA_lakers.reset_index()
LA_lakers.drop(columns=['PLAYER_ID','PLAYER_NAME','SEASON']).median()

#MaxChristie
# MaxChrisie
# Scal_MaxChrisite -> 정규화 Max_Christie
MaxChristie = eff[eff['PLAYER_NAME']=='Max Christie'].copy()
MaxChristie= MaxChristie.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean()
scaleff = scaler.fit_transform(eff.loc[:,'FGM':'PTS'])
scaleff = scaler.fit_transform(scaleff)
scaleff = pd.DataFrame(scaleff,columns=eff.loc[:,'FGM':'PTS'].columns)
scaleff.loc[:,'FGM':'PTS'] = scaleff
Scaleff = eff.copy()
Scaleff.loc[:,'FGM':'PTS'] = scaleff
#Scaleff -> 전체 선수의 정규화 값 ( Min, Efficiency )
Scaleff = Scaleff.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean()
Scaleff = Scaleff.reset_index()
Scaleff[Scaleff['PLAYER_NAME']=='Max Christie']
#cmt_name[cmt_name['PLAYER_NAME']=='Max Christie'].sort_values(by='COMMENT', ascending=False)
#Kendrick Nunn
KendrickNunn = eff[eff['PLAYER_NAME']=='Kendrick Nunn'].copy()
KendrickNunn= KendrickNunn.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean()
#정규화된 선수 수치 찾기
Scaleff[Scaleff['PLAYER_NAME']=='Kendrick Nunn']
#코멘트 찾기
#Numm_cmt = cmt_name[cmt_name['PLAYER_NAME']=='Kendrick Nunn'].sort_values(by='COMMENT', ascending=False)
#umm_cmt = cmt_name[(cmt_name['PLAYER_NAME']=='Kendrick Nunn')&(cmt_name['COMMENT'] != '')].sort_values(by='COMMENT', ascending=False)
#Numm_cmt
#선수 영입
#테이블
#gpmean 각 시즌 필요 스탯별 평균 수치
#gpeff 각 시즌별 선수 스탯
gpeff = eff.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean()
gpeff = gpeff
#gpeff.sort_values(by='EFFICIENCY',ascending=False)
gpeff = gpeff.reset_index()
gpmean = gpeff.drop(columns=['PLAYER_ID', 'PLAYER_NAME'],inplace=False)
gpmean = gpmean.groupby(['SEASON'])[['MIN',
                        'FG3M','FG3_PCT','OREB','DREB','REB','STL','BLK','PTS','EFFICIENCY'
                        ]].mean()
#선수 필터링
#0.73 , 0.52
#gpeff = gpeff.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
#                        'FG3M','FG3A','FG3_PCT','OREB','DREB','REB','STL','BLK','PTS','PLUS_MINUS','EFFICIENCY'
#                        ]].mean()
#pd.set_option('display.max_rows',None)
#선수 필터링
filnba = gpeff[~(gpeff['PLAYER_NAME'].isin(['Giannis Antetokounmpo', 'Nikola Jokic', 'Stephen Curry', 'Kevin Durant', 'LeBron James', 'Luka Doncic', 'Joel Embiid', 'James Harden', 'Kawhi Leonard', 'Damian Lillard']))]
filnba = filnba[(filnba['STL']>=0.73)&(filnba['BLK']>=0.5)&(filnba['MIN']>=10)&(filnba['EFFICIENCY']>=12)]
filnba = filnba[filnba['SEASON']==2021]
filnba2 = filnba.groupby(['PLAYER_ID', 'PLAYER_NAME','SEASON'])[['EFFICIENCY','STL','BLK',
                        'FG3M','FG3_PCT','REB','OREB','DREB','PTS','MIN'
                        ]].mean()
filnba2.sort_values(by='EFFICIENCY',ascending=False)
#
# 2명을 뽑을건데
#1. STL 1명, BLK 1명
#2. 둘다 수준급 1명, 3점슛 1명
#3. 둘다 수준급 2명
#4. 둘 다 수준급 1명, 올라운더 1명(백업용 ->STL BLK 어느정도 하면서 공격수치가 어느정도 되는)
#둘다 수준급
#Robert Covington (1.4 1.2 12)
#Anthony Davis (1.2 2.2 27)
#Draymond Green (1.3 1.0 17)
#Nikola Vucevic(0.9 0.9 23)
#올라운더
#Kyrie Lrvbing (3점슛 3.4 , 스틸 1.4 , EFF 25)
#Bobby Portis (3점슛 1.8 , 리바운드 9.1, OREB 2.5, EFF 18)
#Steven Adams (OREB 4.5 , 리바운드 10, 3점슛 X, EFF 16)

#1. 기준을 세운 이유와 기준이 되는 스탯
#ppt 16p를 통해 팀의 색이 수비형 팀임을 설명 + BLK와 STL  감
#ppt 18p에서 승률과 상관관계 높은 스탯들 중 팀에서 크게 감소한 STL, BLK를 우선순위로 선정
#선수들의 여러 능력치들을 종합적으로 합쳐서 만든 EFFICIENCY 라는 스탯을 테이블에 기재
#-> 위의 자료들을 토대로 최우선으로 EFFICIENCY와 STL, BLK를 보기로 결정, 그리고 부가 옵션으로 3점슛을 잘하는 선수가 있으면 좋겠다고 판단
#-> 필터링 설정
#시즌별 NBA선수들의 평균능력치와 LA_LAKERS의 평균 능력치들을 기준을 보고 위에서 선정한 세가지 스탯을 평균보다 약간 높은 수치로 임의 설정
#평균값 (STL 0.6 ~ 0.62 선정값 0.73, BLK 0.36~0.41 선정값 0.52, EFF 9.4~10.2 선정값 12) + 경기당 참가 시간 10분이상 으로 선정
#-> 테이블 정렬 (STL, BLK, EFFICIENCY 등을 기준으로 정렬)
#*탑플레이어는 영입이 너무 어려울 것으로 제외해 테이블에서 제외 후 검색
#*이전시즌까지 잘한 선수가 필요하기 때문에 21시즌 성적 검색
#STL과 BLK가 모두 1이 넘는 선수를 찾아 나온 Robert Covington
#EFFCIENCY를 기준으로 찾다가 나온 선수 Nikola Vucevic
#(* STL이나 BLK 한쪽으로 1이 넘는 수치는 아니지만 양 스탯이 모두 0.9 이상이고 다른 스탯들을 보니 리바운드나 3점슛 등 전체적으로 양호한 팀에 필요한 올라운더 선수라 판단)

#EFF

#2. 눈여겨본 스탯들을 보기 쉽게 정리한 테이블
LA_lakers

#정규화
#Scaleff가 정규화된 선수들의 데이터

season_column = eff.pop('SEASON')
eff.insert(0, 'SEASON', season_column)

scaleff2 = scaler.fit_transform(eff.loc[:,'FGM':'EFFICIENCY'])
scaleff2 = scaler.fit_transform(scaleff2)
scaleff2 = pd.DataFrame(scaleff2,columns=eff.loc[:,'FGM':'EFFICIENCY'].columns)
scaleff2.loc[:,'FGM':'EFFICIENCY'] = scaleff2
Scaleff = eff.copy()
Scaleff.loc[:,'FGM':'EFFICIENCY'] = scaleff2

#조건출력
Scaleff=Scaleff.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean()
Scaleff=Scaleff.reset_index()

#르브론 제임스 뽑기
#Lebron21 = Scaleff[(Scaleff['PLAYER_NAME']=='LeBron James')&(Scaleff['SEASON']==2021)].copy()
#Lebron21
pd.set_option('display.max_columns',None)
#pd.set_option('display.max_rows',None)
#pd.reset_option('display')
Scaleff[Scaleff['SEASON']==2021].sort_values(by='EFFICIENCY',ascending=False)

Lebron21 = Scaleff[(Scaleff['PLAYER_NAME']=='LeBron James')&(Scaleff['SEASON']==2021)].copy()
Lebron22 = Scaleff[(Scaleff['PLAYER_NAME']=='LeBron James')&(Scaleff['SEASON']==2022)].copy()
Lebron=pd.concat([Lebron21,Lebron22])
Lebron['SEASON']=2022
Lebron = Lebron.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean().reset_index()
Lebron

seasons = ['2022'] # 이 리스트의 첫 번째 시즌을 사용할 것입니다.
kpi_metrics = ['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS']

# 'SEASON' 컬럼을 문자열로 통일 (Scaleff에 직접 적용)
Lebron['SEASON'] = Lebron['SEASON'].astype(str)

# # LeBron James 정규화 수치 (Scaleff에서 LeBron James 데이터 추출)
Lebron = Lebron.loc[Lebron['PLAYER_NAME'] == 'LeBron James', ['SEASON']+kpi_metrics]

# 방사형 좌표 설정
angles = np.linspace(0, 2 * np.pi, len(kpi_metrics), endpoint=False).tolist()
angles += angles[:1]

# 그래프 그리기 (하나의 레이더 차트만 출력)
fig, ax = plt.subplots(figsize=(14, 10), subplot_kw=dict(polar=True))

# 단일 시즌 선택 (여기서는 '2021' 시즌을 가정)
target_season_for_plot = seasons[0]

# --- 문제의 ds_vals 생성 부분 ---
ds_vals = Lebron.loc[Lebron['SEASON'] == target_season_for_plot, kpi_metrics].values.flatten().tolist()

# --- 이 부분이 오류가 나는 부분입니다. ds_vals가 비어있을 때 발생합니다. ---
ds_vals += [ds_vals[0]] # 차트 닫기

ax.plot(angles, ds_vals, marker='o', linewidth=2, color='orange', label='LeBron James')
ax.fill(angles, ds_vals, color='orange',alpha=0.2)


#ax.set_title(f'Season {target_season_for_plot}', size=15, pad=40)
ax.set_thetagrids(np.degrees(angles[:-1]), kpi_metrics, fontsize=15, weight='bold')
ax.set_ylim(-2.0, 2)
ax.axhline(0, color='Gray',alpha=1, linestyle='--', linewidth=1.5)
ax.legend(loc='upper right', fontsize=8)

plt.suptitle(
    'LeBron James',
    fontsize=17, weight='bold', color='#552583' , y = 0.95
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

Anthony21 = Scaleff[(Scaleff['PLAYER_NAME']=='Anthony Davis')&(Scaleff['SEASON']==2021)].copy()
Anthony22 = Scaleff[(Scaleff['PLAYER_NAME']=='Anthony Davis')&(Scaleff['SEASON']==2022)].copy()
Anthony=pd.concat([Anthony21,Anthony22])
Anthony['SEASON']=2022
Anthony = Anthony.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean().reset_index()
Anthony

seasons = ['2022'] # 이 리스트의 첫 번째 시즌을 사용할 것입니다.
kpi_metrics = ['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS']

# 'SEASON' 컬럼을 문자열로 통일 (Scaleff에 직접 적용)
Anthony['SEASON'] = Anthony['SEASON'].astype(str)

# # LeBron James 정규화 수치 (Scaleff에서 LeBron James 데이터 추출)
Anthony = Anthony.loc[Anthony['PLAYER_NAME'] == 'Anthony Davis', ['SEASON']+kpi_metrics]

# 방사형 좌표 설정
angles = np.linspace(0, 2 * np.pi, len(kpi_metrics), endpoint=False).tolist()
angles += angles[:1]

# 그래프 그리기 (하나의 레이더 차트만 출력)
fig, ax = plt.subplots(figsize=(14, 10), subplot_kw=dict(polar=True))

# 단일 시즌 선택 (여기서는 '2021' 시즌을 가정)
target_season_for_plot = seasons[0]

# --- 문제의 ds_vals 생성 부분 ---
ds_vals = Anthony.loc[Lebron['SEASON'] == target_season_for_plot, kpi_metrics].values.flatten().tolist()

# --- 이 부분이 오류가 나는 부분입니다. ds_vals가 비어있을 때 발생합니다. ---
ds_vals += [ds_vals[0]] # 차트 닫기

ax.plot(angles, ds_vals, marker='o', linewidth=2, color='orange', label='Anthony Davis')
ax.fill(angles, ds_vals, color='orange',alpha=0.2)


#ax.set_title(f'Season {target_season_for_plot}', size=15, pad=40)
ax.set_thetagrids(np.degrees(angles[:-1]), kpi_metrics, fontsize=15, weight='bold')
ax.set_ylim(-2.0, 2)
ax.axhline(0, color='Gray',alpha=1, linestyle='--', linewidth=1.5)
ax.legend(loc='upper right', fontsize=8)

plt.suptitle(
    'Anthony Davis',
    fontsize=17, weight='bold', color='#552583' , y = 0.95
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

Patrick21 = Scaleff[(Scaleff['PLAYER_NAME']=='Patrick Beverley')&(Scaleff['SEASON']==2021)].copy()
Patrick22 = Scaleff[(Scaleff['PLAYER_NAME']=='Patrick Beverley')&(Scaleff['SEASON']==2022)].copy()
Patrick=pd.concat([Patrick21,Patrick22])
Patrick = Patrick.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean().reset_index()
Patrick21=Patrick[Patrick['SEASON']==2021][['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']]
Patrick22=Patrick[Patrick['SEASON']==2022][['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']]
Patrick22

kpi_metrics = ['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']
# 방사형 좌표 설정
angles = np.linspace(0, 2 * np.pi, len(kpi_metrics), endpoint=False).tolist()
angles += angles[:1]
# 그래프 그리기 (하나의 레이더 차트만 출력)
fig, ax = plt.subplots(figsize=(14, 10), subplot_kw=dict(polar=True))
# 단일 시즌 선택 (여기서는 '2021' 시즌을 가정)
# target_season_for_plot = seasons[0]
nk_vals = Patrick21[kpi_metrics].values.flatten().tolist()
l4_vals = Patrick22[kpi_metrics].values.flatten().tolist()
# --- 이 부분이 오류가 나는 부분입니다. ds_vals가 비어있을 때 발생합니다. ---
nk_vals += [nk_vals[0]] # 차트 닫기
l4_vals += [l4_vals[0]]
ax.plot(angles, nk_vals, marker='o', linewidth=2, color='orange', label='2021 Season')
ax.plot(angles, l4_vals, marker='s', linewidth=2, color='steelblue', label='2022 Season')
ax.fill(angles, nk_vals, color='orange',alpha=0.2)
ax.fill(angles, l4_vals, color='steelblue',alpha=0.2)
ax.set_title(f'2021 - 2022 Season', size=15, pad=40)
ax.set_thetagrids(np.degrees(angles[:-1]), kpi_metrics, fontsize=15, weight='bold')
ax.set_ylim(-2.0, 2)
ax.axhline(0, color='Gray', linestyle='--', linewidth=1.5)
ax.legend(loc='upper right', fontsize=8)
plt.suptitle(
    'Patrick Beverley',
    fontsize=17, weight='bold', color='#552583' , y = 0.95
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

Kendrick21 = Scaleff[(Scaleff['PLAYER_NAME']=='Kendrick Nunn')&(Scaleff['SEASON']==2020)].copy()
Kendrick22 = Scaleff[(Scaleff['PLAYER_NAME']=='Kendrick Nunn')&(Scaleff['SEASON']==2022)].copy()
Kendrick=pd.concat([Kendrick21,Kendrick22])
Kendrick = Kendrick.groupby(['PLAYER_ID','PLAYER_NAME','SEASON'])[['MIN',
                        'FGM','FGA','FG_PCT','FG3M','FG3A','FG3_PCT','FTM','FTA','FT_PCT','OREB','DREB','REB','AST','STL','BLK','TO','PF','PTS','PLUS_MINUS','EFFICIENCY'
                        ]].mean().reset_index()
Kendrick20=Kendrick[Kendrick['SEASON']==2020][['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']]
Kendrick22=Kendrick[Kendrick['SEASON']==2022][['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']]

kpi_metrics = ['FT_PCT','FG3_PCT','FG_PCT','TO','BLK','STL','REB','AST','PTS','EFFICIENCY']
# 방사형 좌표 설정
angles = np.linspace(0, 2 * np.pi, len(kpi_metrics), endpoint=False).tolist()
angles += angles[:1]
# 그래프 그리기 (하나의 레이더 차트만 출력)
fig, ax = plt.subplots(figsize=(14, 10), subplot_kw=dict(polar=True))
# 단일 시즌 선택 (여기서는 '2021' 시즌을 가정)
# target_season_for_plot = seasons[0]
nk_vals = Kendrick20[kpi_metrics].values.flatten().tolist()
l4_vals = Kendrick22[kpi_metrics].values.flatten().tolist()
# --- 이 부분이 오류가 나는 부분입니다. ds_vals가 비어있을 때 발생합니다. ---
nk_vals += [nk_vals[0]] # 차트 닫기
l4_vals += [l4_vals[0]]
ax.plot(angles, nk_vals, marker='o', linewidth=2, color='orange', label='2020 Season')
ax.plot(angles, l4_vals, marker='s', linewidth=2, color='steelblue', label='2022 Season')
ax.fill(angles, nk_vals, color='orange',alpha=0.2)
ax.fill(angles, l4_vals, color='steelblue',alpha=0.2)
ax.set_title(f'2020, 2022 Season', size=15, pad=40)
ax.set_thetagrids(np.degrees(angles[:-1]), kpi_metrics, fontsize=15, weight='bold')
ax.set_ylim(-2.0, 2)
ax.axhline(0, color='Gray', linestyle='--', linewidth=1.5)
ax.legend(loc='upper right', fontsize=8)
plt.suptitle(
    'Kendrick Nunn',
    fontsize=17, weight='bold', color='#552583' , y = 0.95
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()

#bar_kendrick = Scaleff[Scaleff['PLAYER_NAME']=='Kendrick Nunn'].copy()
Kendrick19 = Scaleff[(Scaleff['PLAYER_NAME']=='Kendrick Nunn')&(Scaleff['SEASON']==2019)].copy()
bar_Kendrick=pd.concat([Kendrick,Kendrick19])

plt.figure(figsize = (10, 5))
sns.barplot(data=bar_Kendrick, x='SEASON', y='EFFICIENCY',color='Gray')

plt.axhline(y=0, color='gray', linestyle='--', linewidth=1.5)

plt.title('EFFICIENCY',fontsize=20,color='#552583',y=1.05) # 그래프 제목 추가 (선택 사항)
plt.xlabel('Season',fontsize=15) # x축 라벨 추가 (선택 사항)
plt.ylabel('Efficiency',fontsize=15) # y축 라벨 추가 (선택 사항)
#plt.legend(title='Player Name') # 범례 제목 추가 (선택 사항)
plt.show()

bar_Patrick = Scaleff[Scaleff['PLAYER_NAME']=='Patrick Beverley'].copy()

plt.figure(figsize = (10, 5))

sns.barplot(data=bar_Patrick, x='SEASON', y='EFFICIENCY',color='Gray',alpha=1)
ax = plt.gca() # 현재 Axes 객체를 가져옵니다.
ax.spines['top'].set_visible(False)    # 위쪽 테두리 제거
ax.spines['right'].set_visible(False)  # 오른쪽 테두리 제거
ax.spines['left'].set_visible(False)   # 왼쪽 테두리 제거
ax.spines['bottom'].set_visible(False)

plt.axhline(y=0, color='gray', linestyle='--', linewidth=1.5)

plt.axhline(y=0, color='gray', linestyle='--', linewidth=1.5)

plt.title('EFFICIENCY',fontsize=20,color='#552583',y=1.05) # 그래프 제목 추가 (선택 사항)
plt.xlabel('Season',fontsize=15) # x축 라벨 추가 (선택 사항)
plt.ylabel('Efficiency',fontsize=15) # y축 라벨 추가 (선택 사항)
plt.show()

bar_Patrick['SEASON'] = bar_Patrick['SEASON'].astype(int)

plt.figure(figsize = (10, 5))

# sns.barplot 대신 sns.lineplot 사용 (수정된 부분)
# marker='o'를 추가하여 각 데이터 포인트에 점을 표시합니다.
# color와 alpha는 막대 그래프와 동일하게 유지할 수 있습니다.
sns.lineplot(data=bar_Patrick, x='SEASON', y='EFFICIENCY', color='Gray', alpha=1, marker='o', linewidth=2)

# 0 지점에 기준선 긋기 (두 번 호출되어 있는데, 한 번만 있어도 됩니다)
plt.axhline(y=0, color='gray', linestyle='--', linewidth=1.5)

# --- x축 틱을 정수 단위로 설정하는 부분 추가 ---
# bar_Patrick에 있는 고유한 시즌 값들을 가져와서 틱으로 설정합니다.
plt.xticks(bar_Patrick['SEASON'].unique())
# -----------------------------------------------

plt.title('EFFICIENCY',fontsize=20,color='#552583',y=1.05) # 그래프 제목 추가 (선택 사항)
plt.xlabel('Season',fontsize=15) # x축 라벨 추가 (선택 사항)
plt.ylabel('Efficiency',fontsize=15) # y축 라벨 추가 (선택 사항)
plt.show()

Kendrick19 = Scaleff[(Scaleff['PLAYER_NAME']=='Kendrick Nunn')&(Scaleff['SEASON']==2019)].copy()
bar_Kendrick=pd.concat([Kendrick,Kendrick19]) # 이 부분은 중복 데이터가 생길 수 있으니 주의하세요.

# 보통은 원하는 데이터만 정확히 필터링해서 사용하는 것이 좋습니다.
# 예를 들어, 특정 선수의 모든 시즌 데이터가 필요하면:
# bar_Kendrick = Scaleff[Scaleff['PLAYER_NAME']=='Kendrick Nunn'].sort_values('SEASON').copy()

plt.figure(figsize = (10, 5))

sns.lineplot(data=bar_Kendrick, x='SEASON', y='EFFICIENCY', color='Gray', marker='o', linewidth=2)


plt.axhline(y=0, color='gray', linestyle='--', linewidth=1.5)


# --- x축 틱을 정수 단위로 설정하는 부분 추가 ---
# bar_Kendrick에 있는 고유한 시즌 값들을 가져와서 틱으로 설정합니다.
# 만약 틱이 촘촘하지 않게 나오거나, 특정 범위의 틱만 원하면 `range()` 등을 활용할 수 있습니다.
plt.xticks(bar_Kendrick['SEASON'].unique())
# -----------------------------------------------

plt.title('EFFICIENCY',fontsize=20,color='#552583',y=1.05)
plt.xlabel('Season',fontsize=15)
plt.ylabel('Efficiency',fontsize=15)
plt.show()